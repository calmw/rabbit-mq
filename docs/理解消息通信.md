#### 消息通信的概念

    当提到消息通信时，程序会员们会联想到许多不同的事物。脑海里最先浮现的是邮箱和IM(即时通信)。RabbitMQ的的消息通信是完全不同的模式。虽然AMQP（高级消息队列协议）像邮箱那样为离线消费者存储消息，但是这些根据标签路由的消息更为灵活。不同于IM协议，AMQP隐去了消息的发送方和接收方。AMQP消息能以一对多的广播方式进行路由，也可以选择一对一的方式进行路由。在IM中只能一对一通信。
    消息包含两部分：有效载荷（payload）和标签（label）
    不同于TCP协议的是，当你明确指定发送方和接收方时，AMQP只会用标签表述这条消息（一个交换器的名称和可选的主题标记），然后把消息交给RabbitMQ。RabbitMQ会根据标签把消息发送给感兴趣的接收方。生产者会创建消息并设置标签。
    当消费者收到消息时，他只会得到消息的一部分：有效载荷。在消息路由过程中，消息的标签并没有随有效载荷一同传递。RabbitMQ不会告诉消费者是谁生产/发送了消息。

#### 信道

    你必须先连接到RabbitMQ，才能消费或者发布消息，你在应用程序和RabbitmQ服务器之间创建了一条TCP连接，一旦TCP连接打开（你通过了认证），应用程序就可以创建一条AMQP信道。信道是创建在真实TCP连接内的虚拟连接。AMQP命令都是通过信道发送出去的。每条信道都会被指派一个唯一ID（AMQP库会帮你记住ID的）。不论是发布消息、订阅消息或是接收消息，这些动作都是通过信道完成的。你也许会问为什么我们需要信道呢？为什么不直接通过TCP连接发送AMQP命令呢？主要原因在于对操作系统来说建立和销毁TCP会话是非常昂贵的开销
    在一条TCP连接上创建多少条信道是没有限制的。
    多个线程可以共享连接，每个线程可以分配一个信道。

#### 队列

    从概念上讲，AMQP消息路由必须有三部分：交换器、队列和绑定。
    生产者把消息发布到交换器上；消息最终到达队列，并被消费者接收；绑定决定了消息如何从交换器到指定的队列。
    消费这通过以下两种方式从特定的队列中接收消息
        1）通过AMQP的basic.consume命令订阅。这样做会将信道置为接收模式，直到取消对队列的订阅为止。订阅了消息后，消费者在消费（或者拒绝）最近接收的那条消息后，就能从队列中（可用的）自动接收下一条消息。如果消费者处理队列消息，并且/或者需要在消息一到达队列就自动接收的话，你应该使用basic.consume。
        2）某些时候，你只想从队列获得单条消息而不是持续订阅。向队列请求单条消息是通过AMQP的basic.get命令实现的。如果需要获取更多消息的话，需要再次发送basic.get命令。你不应该将basic.get放在一个循环里来代替basic.consume，因为这样做会影响Rabbit的性能。大致上讲，basic,get命令会订阅消息、获得单条消息，然后取消订阅。消费者理应使用basic.consume来实现高吞吐量。
    如果消息达到了无人订阅的队列，消息会在队列中等待，一旦有消费者订阅该队列那么队列上的消息就会发送给消费者。
    当一个RabbitMQ队列拥有多个消费者时，队列收到消息将以循环的方式发送给消费者。每条消息只会发送给一个订阅的消费者。假设Bob和Jim订阅了seed_bin队列，当消息到达时，消息的投递方式如下：
        1）消息Msg_A到达seed_bin队列
        2）RabbitMQ把Msg_A发送给Bob
        3) Bob确认接收到了消息Msg_A
        4) RabbitMQ把消息Msg_A从seed_bin队列删除
        5）消息Msg_B到达seed_bin队列
        6）RabbitMQ把Msg_B发送给JIm
        7) Jim确认接收到了消息Msg_B
        8) RabbitMQ把消息Msg_B从seed_bin队列删除
    消费者在接收到的每一条消息都必须确认。消费者必须通过AMQP的basic.ack命令显式地向RabbitMQ发送一个确认，或者在订阅队列的时候将auto.ack设置为true。当设置了auto.ack为true时，一旦消费者接收消息，RabbitMQ会自动视其确认了消息。需要记住的是，消费者对消息的确认和告诉消息生产者消息已经被接受了这两件事毫不相关。因此，消费者通过确认命令告诉RabbitMQ他已经正确接收了消息，此时RabbitMQ才能安全的把消息从队列中删除。
    